# Assignment2

# 1. Image matching and clustering

## 1.1 Image matching
Counts the number of matching ORB/SIFT descriptors across the two images
We implemented 2 method for counting, compare() which based on the Euclidean distance bewteen two descriptors and find the two closest matches and the buildin compareknn() which based on the K nearest neighbors algorithm to find the closest matches.
To visualize, I created the function drawMatches() that connect the matches points between two images.
## 1.2 Clustering
Organizes a set of unordered images into k groups
Here, we calculate the number of matching points into a Matrix. The more matches points means the more similar the two images is.
We implemented groupMatrix() that takes the distance Matrix, the number of groups, then output the groups index based on the similarity of two images.
## 1.3 Test and Examples
We implemented the part1test.py that takes the txt file generated by the above code and output the error rate.
Here are some sample input, error rate and explaination

1. python3 part1.py 2 bigben_2.jpg bigben_3.jpg colosseum_4.jpg colosseum_5.jpg output.txt  
  error rate : 0
  
2. python3 part1.py 3 eiffel_1.jpg eiffel_15.jpg bigben_2.jpg bigben_3.jpg colosseum_4.jpg colosseum_5.jpg output.txt
  error rate : 0.166666  
  ['eiffel_15.jpg']['colosseum_4.jpg', 'colosseum_5.jpg']['eiffel_1.jpg', 'bigben_2.jpg', 'bigben_3.jpg']  
  eiffel_1.jpg has total different angle compared with eiffel_15.jpg probably it thinks that the triangle on the top is similar to bigben.
  
3. python3 part1.py 3 eiffel_1.jpg eiffel_15.jpg bigben_2.jpg bigben_3.jpg colosseum_4.jpg colosseum_5.jpg colosseum_8.jpg colosseum_11.jpg output.txt
  error rate : 0.39285714285714285  
  ['eiffel_15.jpg']['colosseum_4.jpg', 'colosseum_5.jpg']['bigben_2.jpg', 'eiffel_1.jpg', 'bigben_3.jpg', 'colosseum_8.jpg', 'colosseum_11.jpg']  
  'colosseum_4.jpg', 'colosseum_5.jpg' are from the inside of colosseum and 'colosseum_8.jpg', 'colosseum_11.jpg'are from outside can explain this case.
  
4. python3 part1.py 3 eiffel_19.jpg eiffel_18.jpg bigben_2.jpg bigben_3.jpg colosseum_4.jpg colosseum_5.jpg output.txt
  error rate: 0.16666666666666666  
  ['bigben_2.jpg']['colosseum_4.jpg', 'colosseum_5.jpg']['eiffel_19.jpg', 'eiffel_18.jpg', 'bigben_3.jpg']  
  'eiffel_19.jpg', 'eiffel_18.jpg', 'bigben_3.jpg' have a clear triangle on top and make those images in the same group


Using knn version:
1. python3 part1.py 4 eiffel_1.jpg eiffel_15.jpg bigben_2.jpg bigben_3.jpg colosseum_4.jpg colosseum_5.jpg colosseum_8.jpg colosseum_11.jpg output.txt
	Error rate: 0.26785714285714285
	[['eiffel_1.jpg']['eiffel_15.jpg']\['bigben_3.jpg']['bigben_2.jpg', 'colosseum_4.jpg', 'colosseum_5.jpg', 'colosseum_8.jpg', 'colosseum_11.jpg']]
2. python3 part1.py 2 bigben_2.jpg bigben_3.jpg colosseum_4.jpg colosseum_5.jpg output.txt
	Error rate:0.25
	[['bigben_3.jpg'], ['bigben_2.jpg', 'colosseum_4.jpg', 'colosseum_5.jpg']]

In general, error rate of Knn version is higher but run faster.
# 2. Image Transformation
## 2.1
-Part 1: a2_part2_1.py
Transforms an image by applying a transformation matrix.
1. Performs the dot product of a transformation matrix and the pixels of an input image to transform the image.
2. After the transformation, the image will have some missing pixels that gets lost during the process. So a form of "splatting" is applied to estimate the pixel values that are missing. This interpolation method does not give the best result, but is a significant improvement without any interpolation. 
We did try to implement a bilinear interpolation, but was not successful. The main issue that was encountered when trying to perform the bilinear interpolation is in the inverse warping. In our forward warping process, negative pixel values were created after the matrix transformation which means that the transformed image is not properly aligned on the coordinate system. To remedy this, the minimum y and x values are subtracted from the entire transformed image array as a way to reposition the image. Since our coordinates have been translated, inverse warping the new image yields in inaccurate translations.

## 2.2
-Part 2: a2_part2_2.py
Takes in 2 images and 4 pixel coordinates for each image. It then mapps the 4 points of one of the images onto the 4 points on the other image through a perspective transformation.
1. In order to map the 4 coordinate points of one image to another, we must find the correct transformation matrix to apply to the image. To do this, we write our transformation function as V' = M * V, where V is the coordinate of a pixel value and M is the transformation matrix, and solve for M as a system of linear equations with our available coordinate points. This is done in the "get_transformation_matrix()" function.
2. Once we have our transformation matrix, we then use our transformation function to apply it to the image in order to match the perspective of one image to the other image.

# 3. Image matching and clustering
First we read the img and expand the size with black. By using orb, we can find the numbers of matching points. To make the program run fast, we directly to the knn version of match since we can only combine two image that super similar. We setup the filter which is good[] that only keep the highly similar points. We set the threshold of min good matches to 10. Then we use build in RANSAC to find the best 4 points and warp Matrix. By the matrix we can find the warp Image. To combine two images, we set the part that both image have to 1/2 of each image.

Success:

python3 part3.py a.jpg b.jpg output.jpg

python3 part3.py bigben_14_a.jpg bigben_14_b.jpg output.jpg

Failed:

python3 part3.py bigben_14.jpg bigben_8.jpg output.jpg

Since the warpImg is not good. The combined image work only if we can find a good warpImg.
# 4. Running Examples
Let's use a-3 for example:
```
cd part1-images
python3 part1.py 2 bigben_2.jpg bigben_3.jpg colosseum_4.jpg colosseum_5.jpg output.txt
python3 part1test.py


python3 part3.py a.jpg b.jpg output.jpg
```

# 5. Refernece
https://docs.opencv.org/3.4.1/d1/de0/tutorial_py_feature_homography.html
https://web.archive.org/web/20150222120106/xenia.media.mit.edu/~cwren/interpolator/
